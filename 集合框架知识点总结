集合
    Collection(单列集合）
         List(有序，可重复）
             ArrayList
                 底层数据结构是数组，查询快，增删慢
                 线程不安全，效率高
             Vector
                 底层数据结构是数组，查询快，增删慢
                 线程安全，效率低
              LinkedList
                  底层数据结构是链表，查询慢，增删快
                  线程不安全，效率高
           Set(无序，唯一）
               HashSet
                  底层数据结构是哈希表。
                  哈希表依赖两个方法：hasCode()和equals()
                  执行顺序：
                      首先判断hasCode()值是否相同
                         是：继续执行equals(),看其返回值
                             是true:说明元素重复，不添加
                             是false：就直接添加到集合
                         否：就直接添加到集合
                   最终：
                       自动生成hasCode()和equals()即可
    Map(双列集合）
         A：Map集合的数据结构仅仅针对键有效，与值无关。
         B:存储的键值对形式的元素，键唯一，值可重复。
         HashMap
             底层数据结构是哈希表。线程不安全，效率高
                 哈希表依赖两个方法：hashCode()和equals()
                 执行顺序：
                      首先判断hashCode()值是否相同
                             是：继续执行equals（）,看其返回值
                                  是：继续执行equals(),看其返回值
                                      是true:说明元素重复，不添加
                                      是false:就直接添加到集合
                                  否:就直接添加到集合
                        最终：
                           自动生成hashCode()和equals()即可
               LinkedHashMap
                   底层数据结构由链表和哈希表组成。
                       由链表保证元素有序。
                       由哈希表保证元素单一。
           Hashtable
                   底层数据结构是哈希表。线程不安全，效率低
                       哈希表依赖两个方法：hashCode()和equals（）
                       执行顺序：
                          首先判断hashCode()值是否相同
                             是：继续执行equals（）,看其返回值
                                  是：继续执行equals(),看其返回值
                                      是true:说明元素重复，不添加
                                      是false:就直接添加到集合
                                  否:就直接添加到集合
                        最终：
                           自动生成hashCode()和equals()即可
             TreeMap
                 底层数据结构是红黑树。（是一种自平衡树）
                      如何保证元素的唯一性呢？
                           根据比较返回值是否是0来决定
                       如何保证元素的排序呢？
                           两种方式
                              自然排序（元素具备比较性）
                                  让元素所属的类实现Comparable接口
                               比较器排序（集合具备比较性）
                                  让集合接收一个Comparator的实现类对象
                       
                      
